import argparse
import os
import sys
import json
from diffco import DiffCo, MultiDiffCo
from diffco import kernel
from matplotlib import pyplot as plt
import numpy as np
import torch
from diffco.model import RevolutePlanarRobot
import fcl
from scipy import ndimage
from matplotlib import animation
from matplotlib.patches import Rectangle, FancyBboxPatch, Circle
import seaborn as sns
sns.set()
import matplotlib.patheffects as path_effects
from diffco import utils, CollisionChecker
from diffco.Obstacles import FCLObstacle
from diffco.routines import fit_checker, get_estimator, train_checker, train_test_split, unpack_dataset, test_checker, autogenerate_2d_dataset

from visualize_trajectory_2d import animation_demo, create_plots, single_plot
from escape import OptimSampler

from collections import Callable

def main(
        dataset_filepath: str = None,
        checker_type: CollisionChecker = MultiDiffCo,
        start_cfg: torch.Tensor = None,
        num_waypoints: int = 20,
        safety_margin: torch.Tensor = -0.3,
        lr: float = 5e-2,
        record_freq: int = 1,
        post_transform: Callable = None,
        cache: bool = False,
        random_seed: int = 100,):
    """Main entry point for the script. Loads a dataset, trains/loads a checker,
    let the start config follow checker gradients, and creates
    a plot and video animation saved in the `figs/` directory.

    Args:
        dataset_filepath (str): Path to dataset. If not provided, an
            autogenerated dataset will be used.
        checker_type (CollisionChecker): The collision checker class. Should be
            either MultiDiffCo or DiffCo. Defaults to MultiDiffCo.
        start_cfg (Tensor): The starting configuration. If not provided, a
            random configuration will be chosen from the in-collision ones.
        num_waypoints (int): The number of intermediate steps in the path from
            start to target configuration. Defaults to 12.
        safety_margin (Tensor): The safety bias to apply to the different
            classes of obstacles. Defaults to None.
        cache (bool): Flag for loading cached trajectory corresponding to the 
            current dataset. Defaults to False.
        random_seed (int): Random seed used to reproduce the same results,
            useful for debugging. Defaults to 19961221.
    """
    if dataset_filepath is None:
        dataset_filepath = autogenerate_2d_dataset(3, 5, 'class', '2class_1', link_length=2,
            random_seed=random_seed)
    robot, cfgs, labels, dists, obstacles = unpack_dataset(dataset_filepath)
    # obstacles = [obs+(i, ) for i, obs in enumerate(obstacles)]
    fkine = robot.fkine

    # Train on 75% of the data or 10,000 instances, whichever is smaller
    train_indices, test_indices = train_test_split(len(cfgs), min(int(0.75 * len(cfgs)), 10000))
    if labels.dim() > 1 and checker_type != MultiDiffCo:
        raise ValueError(f'If data is nonbinary you must use MultiDiffCo, not {checker_type}')
    description = os.path.splitext(os.path.basename(dataset_filepath))[0]  # Remove the .pt extension
    checker = train_checker(checker_type, cfgs[train_indices], labels[train_indices],
        dists[train_indices], fkine, obstacles, description)
    test_checker(checker, checker.score, cfgs[test_indices], labels[test_indices])
    fit_checker(checker, fitting_epsilon=1, fitting_target='label', fkine=fkine)
    dist_est = get_estimator(checker, scoring_method='rbf_score')
    print('MIN_SCORE = {:.6f}'.format(dist_est(cfgs[test_indices]).min()))

    cfg_path_plots = []
    if robot.dof > 2:
        fig, ax, link_plot, joint_plot, eff_plot = create_plots(robot, obstacles, dist_est, checker)
    elif robot.dof == 2:
        fig, ax, link_plot, joint_plot, eff_plot, cfg_path_plots = create_plots(robot, obstacles, dist_est, checker)

    labels = labels.reshape(len(labels), -1)
    col_cfgs = cfgs[(labels == 1).any(axis=1)]
    indices = np.random.default_rng(random_seed).choice(len(col_cfgs), 1, replace=False)
    if start_cfg is None:
        start_cfg = col_cfgs[indices[0]]
    else:
        assert len(start_cfg) == col_cfgs.shape[-1]

    path_dir = 'results/escape'
    os.makedirs(path_dir, exist_ok=True)
    traj_optim_cached_filepath = os.path.join(path_dir, f'path_{description}.json')
    if cache and os.path.exists(traj_optim_cached_filepath):
        with open(traj_optim_cached_filepath, 'r') as f:
            optim_rec = json.load(f)
    else:
        if safety_margin is None:
            safety_margin = torch.zeros(labels.shape[-1])
        else:
            assert labels.shape[-1] == len(safety_margin)
        esc_options = {
            'N_WAYPOINTS': num_waypoints,
            'safety_margin': safety_margin,
            'lr': lr,
            'record_freq': record_freq,
            'post_transform': post_transform,
        }
        optim_sampler = OptimSampler(robot, dist_est, args=esc_options)
        esc_path, cnt_check = optim_sampler.optim_escape(start_cfg)
        optim_rec = {
            'solution': esc_path.detach().cpu().numpy().tolist(),
            'cnt_check': cnt_check,
        }
        with open(traj_optim_cached_filepath, 'w') as f:
            json.dump(optim_rec, f, indent=4)
            print('Plan recorded in {}'.format(f.name))

    # single_plot(robot, torch.FloatTensor(optim_rec['solution']), fig, link_plot, joint_plot, eff_plot, cfg_path_plots=cfg_path_plots, ax=ax)
    # plt.tight_layout()
    fig_dir = 'figs/escape'
    # os.makedirs(fig_dir, exist_ok=True)
    # plt.savefig(os.path.join(fig_dir, f'path_{description}.png'), dpi=500)
    animation_demo(robot, torch.FloatTensor(optim_rec['solution']), fig, link_plot, joint_plot,
        eff_plot, cfg_path_plots, save_dir=os.path.join(fig_dir, f'path_{description}.gif'))


if __name__ == "__main__":
    desc = 'Tool for generating escaping trajectories for 2D workspaces.'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('-d', '--dataset', dest='dataset_filepath', help='Dataset filepath')
    parser.add_argument('--checker', dest='checker_type', help='Collision checker class',
        choices=['diffco', 'multidiffco'], default='diffco')

    parser.add_argument('--start-cfg', nargs='*', type=float, help='Start configuration')
    parser.add_argument('--num-waypoints', type=int, default=20, help='Number of waypoints')
    parser.add_argument('--safety-margin', nargs='*', type=float, default=[-0.3], help='Safety margin')
    parser.add_argument('--lr', type=float, default=5e-2, help='Learning rate')
    parser.add_argument('--record-freq', type=int, default=1, help='Record frequency')
    parser.add_argument('--post-transform', type=str, choices=['none', 'angular', 'se2', 'se3', 'custom'], help='Post transform')

    parser.add_argument('--cache', action='store_true', default=False)
    parser.add_argument('--random-seed', type=int, default=100)
    args = parser.parse_args()

    if args.checker_type == 'diffco':
        args.checker_type = DiffCo
    elif args.checker_type == 'multidiffco':
        args.checker_type = MultiDiffCo
    
    if args.start_cfg:
        args.start_cfg = torch.Tensor(args.start_cfg)
    if args.safety_margin:
        args.safety_margin = torch.Tensor(args.safety_margin)
    
    if args.post_transform == 'none':
        args.post_transform = None
    elif args.post_transform == 'angular':
        args.post_transform = utils.wrap2pi
    elif args.post_transform == 'se2':
        args.post_transform = utils.se2_wrap2pi
    elif args.post_transform == 'se3':
        raise NotImplementedError
    elif args.post_transform == 'custom':
        def custom_transform(x):
            # fill in your custom transform here
            pass
        args.post_transform = custom_transform

    main(**vars(args))
