import argparse
import os
import sys
import json
from diffco import DiffCo, MultiDiffCo
from diffco import kernel
from matplotlib import pyplot as plt
import numpy as np
import torch
from diffco.model import RevolutePlanarRobot
import fcl
from scipy import ndimage
from matplotlib import animation
from matplotlib.patches import Rectangle, FancyBboxPatch, Circle
import seaborn as sns
sns.set()
import matplotlib.patheffects as path_effects
from diffco import utils, CollisionChecker
from diffco.Obstacles import FCLObstacle
from trajectory_optim import adam_traj_optimize
from distest_error_vis import fit_checker, get_estimator, train_checker, train_test_split, unpack_dataset, test_checker, autogenerate_dataset
from visualize_trajectory_2d import animation_demo, create_plots, single_plot


def main(
        dataset_filepath: str = None,
        checker_type: CollisionChecker = MultiDiffCo,
        start_cfg: torch.Tensor = None,
        target_cfg: torch.Tensor = None,
        num_waypoints: int = 12,
        safety_margin: torch.Tensor = None,
        cache: bool = False,
        random_seed: int = 100,):
    """Main entry point for the script. Loads a dataset, trains/loads a checker,
    calculates an optimal path from start to target configuration, and creates
    a plot and video animation saved in the `figs/` directory.

    Args:
        dataset_filepath (str): Path to dataset. If not provided, an
            autogenerated dataset will be used.
        checker_type (CollisionChecker): The collision checker class. Should be
            either MultiDiffCo or DiffCo. Defaults to MultiDiffCo.
        start_cfg (Tensor): The starting configuration. If not provided, a
            random configuration from the set of collision-free configurations
            will be chosen.
        target_cfg (Tensor): The target configuration. If not provided, a
            random configuration from the set of collision-free configurations
            will be chosen.
        num_waypoints (int): The number of intermediate steps in the path from
            start to target configuration. Defaults to 12.
        safety_margin (Tensor): The safety bias to apply to the different
            classes of obstacles. Defaults to None.
        cache (bool): Flag for loading cached trajectory corresponding to the 
            current dataset. Defaults to False.
        random_seed (int): Random seed used to reproduce the same results,
            useful for debugging. Defaults to 19961221.
    """
    if dataset_filepath is None:
        dataset_filepath = autogenerate_dataset(3, 5, 'class', '2class_1', link_length=2,
            random_seed=random_seed)
    robot, cfgs, labels, dists, obstacles = unpack_dataset(dataset_filepath)
    obstacles = [obs+(i, ) for i, obs in enumerate(obstacles)]
    fkine = robot.fkine

    # Train on 75% of the data or 10,000 instances, whichever is smaller
    train_indices, test_indices = train_test_split(len(cfgs), min(int(0.75 * len(cfgs)), 10000))
    if labels.dim() > 1 and checker_type != MultiDiffCo:
        raise ValueError(f'If data is nonbinary you must use MultiDiffCo, not {checker_type}')
    description = os.path.splitext(os.path.basename(dataset_filepath))[0]  # Remove the .pt extension
    checker = train_checker(checker_type, cfgs[train_indices], labels[train_indices],
        dists[train_indices], fkine, obstacles, description)
    test_checker(checker, checker.score, cfgs[test_indices], labels[test_indices])
    fit_checker(checker, fitting_epsilon=1, fitting_target='label', fkine=fkine)
    dist_est = get_estimator(checker, scoring_method='rbf_score')
    print('MIN_SCORE = {:.6f}'.format(dist_est(cfgs[test_indices]).min()))

    cfg_path_plots = []
    if robot.dof > 2:
        fig, ax, link_plot, joint_plot, eff_plot = create_plots(robot, obstacles, dist_est, checker)
    elif robot.dof == 2:
        fig, ax, link_plot, joint_plot, eff_plot, cfg_path_plots = create_plots(robot, obstacles, dist_est, checker)

    free_cfgs = cfgs[(labels == -1).all(axis=1)]
    indices = np.random.default_rng(random_seed).choice(len(free_cfgs), 2, replace=False)
    if start_cfg is None:
        start_cfg = free_cfgs[indices[0]]
    else:
        assert len(start_cfg) == free_cfgs.shape[-1]
    if target_cfg is None:
        target_cfg = free_cfgs[indices[1]]
    else:
        assert len(target_cfg) == free_cfgs.shape[-1]

    path_dir = 'results/safetybias'
    os.makedirs(path_dir, exist_ok=True)
    traj_optim_cached_filepath = os.path.join(path_dir, f'path_{description}.json')
    if cache and os.path.exists(traj_optim_cached_filepath):
        with open(traj_optim_cached_filepath, 'r') as f:
            optim_rec = json.load(f)
    else:
        if safety_margin is None:
            safety_margin = torch.zeros(labels.shape[-1])
        else:
            assert labels.shape[-1] == len(safety_margin)
        optim_options = {
            'N_WAYPOINTS': num_waypoints,
            'NUM_RE_TRIALS': 10,
            'MAXITER': 200,
            'safety_margin': safety_margin,
            'max_speed': 0.3,
            'seed': random_seed,
            'history': False
        }
        optim_rec = adam_traj_optimize(robot, dist_est, start_cfg, target_cfg, options=optim_options)
        with open(traj_optim_cached_filepath, 'w') as f:
            json.dump(optim_rec, f, indent=4)
            print('Plan recorded in {}'.format(f.name))

    single_plot(robot, torch.FloatTensor(optim_rec['solution']), fig, link_plot, joint_plot, eff_plot, cfg_path_plots=cfg_path_plots, ax=ax)
    plt.tight_layout()
    fig_dir = 'figs/safetybias'
    os.makedirs(fig_dir, exist_ok=True)
    plt.savefig(os.path.join(fig_dir, f'path_{description}.png'), dpi=500)
    animation_demo(robot, torch.FloatTensor(optim_rec['solution']), fig, link_plot, joint_plot,
        eff_plot, cfg_path_plots, save_dir=os.path.join(fig_dir, f'path_{description}.mp4'))


if __name__ == "__main__":
    desc = 'Tool for generating optimized trajectories for 2D workspaces.'
    parser = argparse.ArgumentParser(description=desc)
    parser.add_argument('-d', '--dataset', dest='dataset_filepath', help='Dataset filepath')
    parser.add_argument('--checker', dest='checker_type', help='Collision checker class',
        choices=['diffco', 'multidiffco'], default='multidiffco')
    parser.add_argument('--start-cfg', nargs='*', type=float, help='Start configuration')
    parser.add_argument('--target-cfg', nargs='*', type=float, help='Final configuration')
    parser.add_argument('--num-waypoints', type=int, default=12, help='Number of waypoints')
    parser.add_argument('--safety-margin', nargs='*', type=float, help='Safety margin')
    parser.add_argument('--cache', action='store_true', default=False)
    parser.add_argument('--random-seed', type=int, default=100)
    args = parser.parse_args()

    if args.checker_type == 'diffco':
        args.checker_type = DiffCo
    elif args.checker_type == 'multidiffco':
        args.checker_type = MultiDiffCo
    
    if args.start_cfg:
        args.start_cfg = torch.Tensor(args.start_cfg)
    if args.target_cfg:
        args.target_cfg = torch.Tensor(args.target_cfg)
    if args.safety_margin:
        args.safety_margin = torch.Tensor(args.safety_margin)

    main(**vars(args))
